{"version":3,"file":"index.js","sources":["../../src/node/utils.ts","../../src/node/category.ts","../../src/node/compact.ts","../../src/node/type.ts","../../src/node/plugin.ts"],"sourcesContent":["import { type App, type Page } from \"@vuepress/core\";\nimport { Logger, keys } from \"vuepress-shared/node\";\n\nimport { type PageMap } from \"./typings/index.js\";\n\nexport const PLUGIN_NAME = \"vuepress-plugin-blog2\";\n\nexport const logger = new Logger(PLUGIN_NAME);\n\nexport const getPageMap = (\n  filter: (page: Page) => boolean,\n  app: App\n): PageMap => {\n  const pageMap: PageMap = {};\n\n  // initialize pageMap\n  keys({\n    // make sure root locale exists\n    // eslint-disable-next-line @typescript-eslint/naming-convention\n    \"/\": {},\n    ...app.options.locales,\n  }).forEach((path) => {\n    pageMap[path] = [];\n  });\n\n  app.pages.filter(filter).forEach((page) => {\n    pageMap[page.pathLocale].push(page);\n  });\n\n  return pageMap;\n};\n","import { type App, type Page, createPage } from \"@vuepress/core\";\nimport { isFunction, isString, removeLeadingSlash } from \"@vuepress/shared\";\nimport { colors } from \"@vuepress/utils\";\n\nimport { type BlogOptions } from \"./options.js\";\nimport { type PageMap } from \"./typings/index.js\";\nimport { logger } from \"./utils.js\";\nimport { type CategoryMap } from \"../shared/index.js\";\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogCategory)\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ categoryMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogCategory(categoryMap);\n  });\n\n`;\n\nexport const prepareCategory = (\n  app: App,\n  { category, slugify }: Required<Pick<BlogOptions, \"category\" | \"slugify\">>,\n  pageMap: PageMap,\n  init = false\n): Promise<string[]> =>\n  Promise.all(\n    category.map(\n      async (\n        {\n          key,\n          getter,\n          sorter = (): number => -1,\n          path = \"/:key/\",\n          layout = \"Layout\",\n          frontmatter = (): Record<string, string> => ({}),\n          itemPath = \"/:key/:name/\",\n          itemLayout = \"Layout\",\n          itemFrontmatter = (): Record<string, string> => ({}),\n        },\n        index\n      ) => {\n        if (!isString(key) || !key.length) {\n          logger.error(\n            `Invalid ${colors.magenta(\"key\")} option ${colors.cyan(\n              key\n            )} in ${colors.cyan(`category[${index}]`)}`\n          );\n\n          return null;\n        }\n\n        if (!isFunction(getter)) {\n          logger.error(\n            `Invalid ${colors.magenta(\"getter\")} option in \"${colors.cyan(\n              `category[${index}]`\n            )}\", it should be a function!`\n          );\n\n          return null;\n        }\n\n        if (app.env.isDebug)\n          logger.info(`Generating ${colors.cyan(key)} category.\\n`);\n\n        const categoryMap: CategoryMap = {};\n        const pageKeys: string[] = [];\n        const getItemPath = isFunction(itemPath)\n          ? itemPath\n          : (name: string): string =>\n              (itemPath || \"\")\n                .replace(/:key/g, slugify(key))\n                .replace(/:name/g, slugify(name));\n\n        for (const localePath in pageMap) {\n          if (path) {\n            const pagePath = `${localePath}${removeLeadingSlash(\n              path.replace(/:key/g, slugify(key))\n            )}`;\n\n            const mainPage = await createPage(app, {\n              path: pagePath,\n              frontmatter: {\n                ...frontmatter(localePath),\n                blog: {\n                  type: \"category\",\n                  key,\n                },\n                layout,\n              },\n            });\n\n            const index = app.pages.findIndex(({ path }) => path === pagePath);\n\n            if (index === -1) {\n              app.pages.push(mainPage);\n            } else if (app.pages[index].key !== mainPage.key) {\n              app.pages.splice(index, 1, mainPage);\n\n              if (init)\n                logger.warn(`Overriding existed path ${colors.cyan(pagePath)}`);\n            }\n            pageKeys.push(mainPage.key);\n\n            categoryMap[localePath] = {\n              path: mainPage.path,\n              map: {},\n            };\n          } else {\n            categoryMap[localePath] = {\n              path: \"\",\n              map: {},\n            };\n          }\n\n          const { map } = categoryMap[localePath];\n          const pageMapStore: Record<string, Page[]> = {};\n\n          for (const page of pageMap[localePath]) {\n            const categories = getter(page);\n\n            for (const category of categories) {\n              if (!map[category]) {\n                const itemPath = getItemPath(category);\n\n                if (itemPath) {\n                  const pagePath = `${localePath}${removeLeadingSlash(\n                    itemPath\n                  )}`;\n\n                  const page = await createPage(app, {\n                    path: `${localePath}${removeLeadingSlash(itemPath)}`,\n                    frontmatter: {\n                      ...itemFrontmatter(category, localePath),\n                      blog: {\n                        type: \"category\",\n                        name: category,\n                        key,\n                      },\n                      layout: itemLayout,\n                    },\n                  });\n\n                  const index = app.pages.findIndex(\n                    ({ path }) => path === pagePath\n                  );\n\n                  if (index === -1) {\n                    app.pages.push(page);\n                  } else if (app.pages[index].key !== page.key) {\n                    app.pages.splice(index, 1, page);\n\n                    if (init)\n                      logger.warn(`Overriding existed path ${pagePath}`);\n                  }\n\n                  pageKeys.push(page.key);\n\n                  map[category] = {\n                    path: page.path,\n                    keys: [],\n                  };\n                } else {\n                  map[category] = {\n                    path: \"\",\n                    keys: [],\n                  };\n                }\n\n                pageMapStore[category] = [];\n              }\n\n              pageMapStore[category].push(page);\n            }\n          }\n\n          for (const category in pageMapStore)\n            map[category].keys = pageMapStore[category]\n              .sort(sorter)\n              .map(({ key }) => key);\n\n          if (app.env.isDebug) {\n            let infoMessage = `Route ${localePath} in ${key} category:\\n`;\n\n            for (const category in map) {\n              const { path, keys } = map[category];\n\n              infoMessage += `name: ${category}; ${\n                path ? `path: ${path}; ` : \"\"\n              }items: ${keys.length}\\n`;\n            }\n\n            logger.info(infoMessage);\n          }\n        }\n\n        return {\n          key,\n          map: categoryMap,\n          pageKeys,\n        };\n      }\n    )\n  ).then(async (result) => {\n    const finalMap: Record<string, CategoryMap> = {};\n    const keys: string[] = [];\n\n    result\n      .filter(\n        (\n          item\n        ): item is {\n          key: string;\n          map: CategoryMap;\n          pageKeys: string[];\n        } => item !== null\n      )\n      .forEach(({ key, map, pageKeys }) => {\n        finalMap[key] = map;\n        keys.push(...pageKeys);\n      });\n\n    await app.writeTemp(\n      `blog/category.js`,\n      `\\\nexport const categoryMap = ${JSON.stringify(finalMap)};\n${app.env.isDev ? HMR_CODE : \"\"}\n`\n    );\n\n    if (app.env.isDebug) logger.info(\"All categories generated.\");\n\n    return keys;\n  });\n","import { colors } from \"@vuepress/utils\";\n\nimport { type BlogOptions } from \"./options.js\";\nimport { logger } from \"./utils.js\";\n\n/** @deprecated */\nexport const convertOptions = (\n  options: BlogOptions & {\n    /** @deprecated */\n    customElement?: (tagName: string) => boolean;\n  }\n): void => {\n  // v2 changes\n  if (\"customElement\" in options) {\n    logger.warn(\n      `${colors.magenta(\n        \"customElement\"\n      )} is deprecated, please use ${colors.magenta(\"isCustomElement\")}.`\n    );\n\n    options[\"isCustomElement\"] = options[\"customElement\"];\n  }\n};\n","import { type App, createPage } from \"@vuepress/core\";\nimport { isString, removeLeadingSlash } from \"@vuepress/shared\";\nimport { colors } from \"@vuepress/utils\";\n\nimport { type BlogOptions } from \"./options.js\";\nimport { type PageMap } from \"./typings/index.js\";\nimport { logger } from \"./utils.js\";\nimport { type TypeMap } from \"../shared/index.js\";\n\nconst HMR_CODE = `\nif (import.meta.webpackHot) {\n  import.meta.webpackHot.accept();\n  if (__VUE_HMR_RUNTIME__.updateBlogType)\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);\n}\n\nif (import.meta.hot)\n  import.meta.hot.accept(({ typeMap }) => {\n    __VUE_HMR_RUNTIME__.updateBlogType(typeMap);\n  });\n`;\n\nexport const prepareType = (\n  app: App,\n  { type, slugify }: Required<Pick<BlogOptions, \"type\" | \"slugify\">>,\n  pageMap: PageMap,\n  init = false\n): Promise<string[]> =>\n  Promise.all(\n    type.map(\n      async (\n        {\n          key,\n          sorter = (): number => -1,\n          filter = (): boolean => true,\n          path = \"/:key/\",\n          layout = \"Layout\",\n          frontmatter = (): Record<string, string> => ({}),\n        },\n        index\n      ) => {\n        if (!isString(key) || !key.length) {\n          logger.error(\n            `Invalid ${colors.magenta(\"key\")} option ${colors.cyan(\n              key\n            )} in ${colors.cyan(`type[${index}]`)}`\n          );\n\n          return null;\n        }\n\n        const typeMap: TypeMap = {};\n        const pageKeys: string[] = [];\n\n        if (app.env.isDebug)\n          logger.info(`Generating ${colors.cyan(key)} type.\\n`);\n\n        for (const localePath in pageMap) {\n          const keys = pageMap[localePath]\n            .filter(filter)\n            .sort(sorter)\n            .map(({ key }) => key);\n\n          if (path) {\n            const pagePath = `${localePath}${removeLeadingSlash(\n              slugify(path.replace(/:key/g, key))\n            )}`;\n\n            const page = await createPage(app, {\n              path: pagePath,\n              frontmatter: {\n                ...frontmatter(localePath),\n                blog: {\n                  type: \"type\",\n                  key,\n                },\n                layout,\n              },\n            });\n\n            const index = app.pages.findIndex(({ path }) => path === pagePath);\n\n            if (index === -1) {\n              app.pages.push(page);\n            } else if (app.pages[index].key !== page.key) {\n              app.pages.splice(index, 1, page);\n\n              if (init)\n                logger.warn(`Overriding existed path ${colors.cyan(pagePath)}`);\n            }\n\n            pageKeys.push(page.key);\n\n            typeMap[localePath] = { path: page.path, keys };\n\n            if (app.env.isDebug)\n              logger.info(\n                `Route ${localePath} in ${key} type: path: ${page.path}; items: ${keys.length}\\n`\n              );\n          } else {\n            typeMap[localePath] = { path: \"\", keys };\n\n            if (app.env.isDebug)\n              logger.info(\n                `Route ${localePath} in ${key} type: items: ${keys.length}\\n`\n              );\n          }\n        }\n\n        return {\n          key,\n          map: typeMap,\n          pageKeys,\n        };\n      }\n    )\n  ).then(async (result) => {\n    const finalMap: Record<string, TypeMap> = {};\n    const keys: string[] = [];\n\n    result\n      .filter(\n        (\n          item\n        ): item is {\n          key: string;\n          map: TypeMap;\n          pageKeys: string[];\n        } => item !== null\n      )\n      .forEach(({ key, map, pageKeys }) => {\n        finalMap[key] = map;\n        keys.push(...pageKeys);\n      });\n\n    await app.writeTemp(\n      `blog/type.js`,\n      `\\\nexport const typeMap = ${JSON.stringify(finalMap)};\n${app.env.isDev ? HMR_CODE : \"\"}\n`\n    );\n\n    if (app.env.isDebug) logger.info(\"All types generated.\");\n\n    return keys;\n  });\n","import {\n  type PluginFunction,\n  preparePageComponent,\n  preparePageData,\n  preparePagesComponents,\n  preparePagesData,\n  preparePagesRoutes,\n} from \"@vuepress/core\";\nimport { watch } from \"chokidar\";\nimport { checkVersion, getPageExcerpt } from \"vuepress-shared/node\";\n\nimport { prepareCategory } from \"./category.js\";\nimport { convertOptions } from \"./compact.js\";\nimport { type BlogOptions, type PageWithExcerpt } from \"./options.js\";\nimport { prepareType } from \"./type.js\";\nimport { PLUGIN_NAME, getPageMap, logger } from \"./utils.js\";\n\nexport const blogPlugin =\n  (options: BlogOptions, legacy = true): PluginFunction =>\n  (app) => {\n    // TODO: remove in V2 Stable\n    if (legacy)\n      convertOptions(options as BlogOptions & Record<string, unknown>);\n\n    checkVersion(app, PLUGIN_NAME, \"2.0.0-beta.61\");\n\n    const {\n      getInfo = (): Record<string, never> => ({}),\n      filter = (page): boolean =>\n        Boolean(page.filePathRelative) && !page.frontmatter[\"home\"],\n      metaScope = \"_blog\",\n      excerpt = true,\n      excerptSeparator = \"<!-- more -->\",\n      excerptLength = 300,\n      excerptFilter = filter,\n      isCustomElement = (): boolean => false,\n      category = [],\n      type = [],\n      slugify = (name: string): string =>\n        name\n          .replace(/[ _]/g, \"-\")\n          .replace(/[:?*|\\\\/<>]/g, \"\")\n          .toLowerCase(),\n    } = options;\n\n    let generatePageKeys: string[] = [];\n\n    if (app.env.isDebug) logger.info(\"Options:\", options);\n\n    return {\n      name: PLUGIN_NAME,\n\n      define: () => ({\n        BLOG_META_SCOPE: metaScope,\n      }),\n\n      extendsPage: (page): void => {\n        if (excerpt && excerptFilter(page))\n          (<PageWithExcerpt>page).data[\"excerpt\"] = getPageExcerpt(app, page, {\n            isCustomElement,\n            excerptSeparator,\n            excerptLength,\n          });\n\n        if (filter(page))\n          page.routeMeta = {\n            ...(metaScope === \"\"\n              ? getInfo(page)\n              : { [metaScope]: getInfo(page) }),\n            ...page.routeMeta,\n          };\n      },\n\n      onInitialized: (app): Promise<void> => {\n        const pageMap = getPageMap(filter, app);\n\n        return Promise.all([\n          prepareCategory(app, { category, slugify }, pageMap, true).then(\n            (pageKeys) => {\n              generatePageKeys.push(...pageKeys);\n            }\n          ),\n          prepareType(app, { type, slugify }, pageMap, true).then(\n            (pageKeys) => {\n              generatePageKeys.push(...pageKeys);\n            }\n          ),\n        ]).then(() => {\n          if (app.env.isDebug) logger.info(\"temp file generated\");\n        });\n      },\n\n      onWatched: (app, watchers): void => {\n        const hotReload =\n          \"hotReload\" in options ? options.hotReload : app.env.isDebug;\n\n        if (hotReload) {\n          const pageDataWatcher = watch(\"pages/**/*.js\", {\n            cwd: app.dir.temp(),\n            ignoreInitial: true,\n          });\n\n          const updateBlog = (): Promise<void> => {\n            const newGeneratedPageKeys: string[] = [];\n\n            const pageMap = getPageMap(filter, app);\n\n            return Promise.all([\n              prepareCategory(app, { category, slugify }, pageMap).then(\n                (pageKeys) => {\n                  newGeneratedPageKeys.push(...pageKeys);\n                }\n              ),\n              prepareType(app, { type, slugify }, pageMap).then((pageKeys) => {\n                newGeneratedPageKeys.push(...pageKeys);\n              }),\n            ]).then(async () => {\n              const pagesToBeRemoved = generatePageKeys.filter(\n                (key) => !newGeneratedPageKeys.includes(key)\n              );\n              const pagesToBeAdded = newGeneratedPageKeys.filter(\n                (key) => !generatePageKeys.includes(key)\n              );\n\n              if (pagesToBeAdded.length) {\n                if (app.env.isDebug)\n                  logger.info(\n                    `New pages detected: ${pagesToBeAdded.toString()}`\n                  );\n\n                // prepare page files\n                await Promise.all(\n                  pagesToBeAdded.map(async (pageKey) => {\n                    await preparePageComponent(\n                      app,\n                      app.pages.find(({ key }) => key === pageKey)!\n                    );\n                    await preparePageData(\n                      app,\n                      app.pages.find(({ key }) => key === pageKey)!\n                    );\n                  })\n                );\n              }\n\n              // remove pages\n              if (pagesToBeRemoved.length) {\n                if (app.env.isDebug)\n                  logger.info(\n                    `Removing following pages: ${pagesToBeRemoved.toString()}`\n                  );\n\n                pagesToBeRemoved.forEach((pageKey) => {\n                  app.pages.splice(\n                    app.pages.findIndex(({ key }) => key === pageKey),\n                    1\n                  );\n                });\n              }\n\n              // prepare pages entry\n              if (pagesToBeRemoved.length || pagesToBeAdded.length) {\n                await preparePagesComponents(app);\n                await preparePagesData(app);\n                await preparePagesRoutes(app);\n              }\n\n              generatePageKeys = newGeneratedPageKeys;\n\n              if (app.env.isDebug) logger.info(\"temp file updated\");\n            });\n          };\n\n          pageDataWatcher.on(\"add\", () => {\n            void updateBlog();\n          });\n          pageDataWatcher.on(\"change\", () => {\n            void updateBlog();\n          });\n          pageDataWatcher.on(\"unlink\", () => {\n            void updateBlog();\n          });\n\n          watchers.push(pageDataWatcher);\n        }\n      },\n    };\n  };\n"],"names":["PLUGIN_NAME","logger","Logger","getPageMap","filter","app","pageMap","keys","path","page","HMR_CODE","prepareCategory","category","slugify","init","key","getter","sorter","layout","frontmatter","itemPath","itemLayout","itemFrontmatter","index","isString","colors","isFunction","categoryMap","pageKeys","getItemPath","name","localePath","pagePath","removeLeadingSlash","mainPage","createPage","map","pageMapStore","categories","infoMessage","result","finalMap","item","convertOptions","options","prepareType","type","typeMap","blogPlugin","legacy","checkVersion","getInfo","metaScope","excerpt","excerptSeparator","excerptLength","excerptFilter","isCustomElement","generatePageKeys","getPageExcerpt","watchers","pageDataWatcher","watch","updateBlog","newGeneratedPageKeys","pagesToBeRemoved","pagesToBeAdded","pageKey","preparePageComponent","preparePageData","preparePagesComponents","preparePagesData","preparePagesRoutes"],"mappings":"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"}